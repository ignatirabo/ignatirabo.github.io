<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

 <title>Ignacio</title>
 <link href="http://hyde.getpoole.com/atom.xml" rel="self"/>
 <link href="http://hyde.getpoole.com/"/>
 <updated>2018-11-12T17:24:37+01:00</updated>
 <id>http://hyde.getpoole.com</id>
 <author>
   <name>Mark Otto</name>
   <email></email>
 </author>

 
 <entry>
   <title>Using the MTele_In function</title>
   <link href="http://hyde.getpoole.com/coq/mtac/2018/11/12/using-mtelein/"/>
   <updated>2018-11-12T15:47:00+01:00</updated>
   <id>http://hyde.getpoole.com/coq/mtac/2018/11/12/using-mtelein</id>
   <content type="html">&lt;p&gt;In the previous post I explained a possible implementation of &lt;code&gt;mbind&lt;/code&gt; which had type:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Coq&quot;&gt;Fixpoint mbind {m : MTele} {A : Type} : forall {B : MTele_Ty m}, M A -&amp;gt; (A -&amp;gt; MFA B) -&amp;gt; MFA B.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now it’s in our interest to change this a little bit.&lt;/p&gt;

&lt;p&gt;Roughly, the type of &lt;code&gt;mBind&lt;/code&gt; we’re now interested:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Fixpoint mbind {m : MTele} : forall {A B : MTele_Ty m}, MFA A -&amp;gt; forall x .. z, (A -&amp;gt; M B) -&amp;gt; MFA B.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To do this a new function is needed.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Coq&quot;&gt;Fixpoint MTele_In (s : Sort) {n : MTele} :
  (forall (now_ty : forall s, MTele_Sort s n -&amp;gt; s)
          (now_val : forall s {T : MTele_Sort s n}, MTele_val T -&amp;gt; now_ty s T), s)
  -&amp;gt; MTele_Sort s n.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It’s not the nicest looking types but it’s fairly simple. First, let’s inspect the type and then what the function does.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;MTele_in&lt;/code&gt; takes &lt;code&gt;s : Sort&lt;/code&gt;, &lt;code&gt;m :MTele&lt;/code&gt; and then quantifies over two functions: &lt;code&gt;now_ty&lt;/code&gt; and &lt;code&gt;now_val&lt;/code&gt;. The idea behind this function is to able to work with various telecosped types at the same time. In the previous version on &lt;code&gt;mbind&lt;/code&gt;, the &lt;code&gt;A&lt;/code&gt; was just a plain coq type so we didn’t need this function. We’re not interested in &lt;code&gt;now_val&lt;/code&gt; for what we’re doing so I’ll just ignore it.&lt;/p&gt;

&lt;p&gt;The function &lt;code&gt;now_ty : forall s, MTele_Sort s n -&amp;gt; s&lt;/code&gt; let’s us access telescoped types as if they were regular Coq types. So what we’re interested in doing is taking our &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; which are &lt;code&gt;MTele_Ty&lt;/code&gt; and be able to write &lt;code&gt;A -&amp;gt; M B&lt;/code&gt;. And that’s we will describe in the signature of the new &lt;code&gt;mbind&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Coq&quot;&gt;Fixpoint mbind {m : MTele} : forall {A B : MTele_Ty m},
                              MFA A -&amp;gt;
                              (MTele_val [withP now_ty , _ =&amp;gt;
                                let A' := now_ty SType A in
                                let B' := now_ty SType B in
                                (A' -&amp;gt; M B')]) -&amp;gt;
                              MFA B :=
  match m with
  | mBase =&amp;gt; fun A B ma f =&amp;gt; @bind A B ma f
  | @mTele X F =&amp;gt; fun A B ma f x =&amp;gt; @mbind (F x) (A x) (B x) (ma x) (f x)
  end.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, the &lt;code&gt;f&lt;/code&gt; function we are left with looks like &lt;code&gt;forall x..z, (A x..z -&amp;gt; M (B x..z))&lt;/code&gt;, so we can use the same approach as before by just adding a variable from the telescope with each step.&lt;/p&gt;

&lt;p&gt;Later we will see why we can’t use this approach to write some functions, for example &lt;code&gt;fix0&lt;/code&gt; which would make a fixpoint with no arguments.&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>Implementing a new bind for Mtac2 with telescopes</title>
   <link href="http://hyde.getpoole.com/coq/mtac/2018/11/09/bind-in-mtac/"/>
   <updated>2018-11-09T15:01:00+01:00</updated>
   <id>http://hyde.getpoole.com/coq/mtac/2018/11/09/bind-in-mtac</id>
   <content type="html">&lt;p&gt;Because &lt;em&gt;Mtac2&lt;/em&gt; uses monads there is a &lt;code&gt;bind&lt;/code&gt; function that has a type&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Coq&quot;&gt;bind : forall {A : Type} {B : Type}, M A -&amp;gt; (A -&amp;gt; M B) -&amp;gt; M B.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;bind&lt;/code&gt; operator is used to concatenate different computations. So given &lt;code&gt;M A&lt;/code&gt;, which means we have a proof of &lt;code&gt;A&lt;/code&gt; wrapped in our monad, we want to use this proof of &lt;code&gt;A&lt;/code&gt; to continue to proof &lt;code&gt;M B&lt;/code&gt;, and so it returns &lt;code&gt;M B&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;problem&lt;/em&gt; that arises from this definition is that this type &lt;em&gt;B&lt;/em&gt; can depend on other types but they have to be already introduced to &lt;em&gt;B&lt;/em&gt;. For example we can’t do the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Coq&quot;&gt;mfix  f a : forall x .. z, M (B x .. z) :=
  a' &amp;lt;- g a;
  mmatch a' as a' return forall x .. z, M (B' a' x .. z)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here &lt;code&gt;bind&lt;/code&gt; is hidden, but it would be something like this&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Coq&quot;&gt;bind (g a) (fun a' =&amp;gt; mmatch a' ...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So the type of &lt;code&gt;fun a' =&amp;gt; mmatch a' ...&lt;/code&gt; is &lt;code&gt;forall a' x .. z, M (B' a' x .. z)&lt;/code&gt; which doesn’t match with the type bind is expecting.&lt;/p&gt;

&lt;p&gt;The idea is to migrate this to something like&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Coq&quot;&gt;mbind : forall {A : Type} {B : X .. Z -&amp;gt; Type}, M A -&amp;gt; (A -&amp;gt; forall x .. z M (B x .. z)) -&amp;gt; M (B x .. z).
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The way I did this is by using &lt;em&gt;telescopes&lt;/em&gt;, or at least that’s what we call them. &lt;em&gt;Telescopes&lt;/em&gt; are actually values of a type &lt;code&gt;MTele&lt;/code&gt;, which is unductively defined as:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Coq&quot;&gt;Inductive MTele : Type :=
| mBase : MTele
| mTele {X : Type} (F : X -&amp;gt; MTele) : MTele
.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By using this type we can express an arbitrary amount of values of different types. For example &lt;code&gt;@mTele nat (fun _ =&amp;gt; @mTele bool (fun _ =&amp;gt; mBase))&lt;/code&gt; describes something that needs a natural number and a boolean value. With a telescope and a set of functions we can express this types we’re looking for. In this case, we’re interested in the following notation to write the type of &lt;code&gt;mbind&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Coq&quot;&gt;Local Notation MFA T := (MTele_val (MTele_C SType SProp M T)).
mbind {A : Type} {m : MTele} : forall {B : MTele_Ty m}, M A -&amp;gt; (A -&amp;gt; MFA B) -&amp;gt; MFA B.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Telescopes&lt;/em&gt; work at three levels:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Syntax&lt;/th&gt;
      &lt;th&gt;Type&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;Let m := @mTele nat (fun _ : nat =&amp;gt; mBase)&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;m : MTele&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;Let A : MTele_Sort SProp m := fun x =&amp;gt; x = x.&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;A : nat -&amp;gt; Type&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;Let a : MTele_val (MTele_C SProp SProp M A) := ...&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;a : forall x : nat, M (C x)&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;At the first level (top) we see the definition of a telescope that takes only a natural number. We use &lt;code&gt;_&lt;/code&gt; because we don’t actually care about the value we take. Now &lt;code&gt;m&lt;/code&gt; has type &lt;code&gt;MTele&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;A&lt;/code&gt; has type &lt;code&gt;MTele_Sort SProp m&lt;/code&gt;. This means that &lt;code&gt;A&lt;/code&gt; is a &lt;code&gt;Prop&lt;/code&gt; that takes a &lt;code&gt;nat&lt;/code&gt;. &lt;code&gt;SProp&lt;/code&gt; is a constructor of &lt;code&gt;Sort&lt;/code&gt; which coerces with &lt;code&gt;Prop&lt;/code&gt;. &lt;code&gt;Sort&lt;/code&gt; means to describe what sort of object we want to produce out of the telescope: it can be a type or a proposition. In this case we’re interested in &lt;code&gt;SProp&lt;/code&gt; because of how &lt;code&gt;A&lt;/code&gt; is defined.&lt;/p&gt;

&lt;p&gt;It’s important to notice that an inhabitant of &lt;code&gt;A&lt;/code&gt; would be a proof of the proposition that it represents. That’s what &lt;code&gt;a&lt;/code&gt; attempts to be. Through those two functions: &lt;code&gt;MTele_val&lt;/code&gt; and &lt;code&gt;MTele_C&lt;/code&gt; we can describe the type of an inhabitant of &lt;code&gt;A&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;MTele_val&lt;/code&gt; computes &lt;code&gt;λ x .. z, T x .. z&lt;/code&gt; from &lt;code&gt;T : MTele_Sort s n&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;MTele_C&lt;/code&gt; maps an &lt;code&gt;MTele_Sort s m&lt;/code&gt; with a constant function, in this case &lt;code&gt;M&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This is the implentation of &lt;code&gt;mbind&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Coq&quot;&gt;Fixpoint mbind {m : MTele} {A : Type} : forall {B : MTele_Ty m}, M A -&amp;gt; (A -&amp;gt; MFA B) -&amp;gt; MFA B :=
  match m with
  | mBase =&amp;gt; fun B ma f =&amp;gt; @bind A B ma f
  | @mTele X F =&amp;gt; fun B ma f x =&amp;gt; @mbind (F x) A (B x) ma (fun a =&amp;gt; f a x)
  end.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The way this works is by induction on the telescope. When the telescope is &lt;code&gt;mBase&lt;/code&gt; we just use the regular &lt;code&gt;bind&lt;/code&gt;, because we don’t have any kind of argument of any type that we want to “add” to &lt;code&gt;B&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;When the telescope is &lt;code&gt;@mTele X F&lt;/code&gt; we just peel one layer of the telescope by each recursive step. Notice the last argument of &lt;code&gt;mbind&lt;/code&gt;, the function, uses the original &lt;code&gt;f&lt;/code&gt; but it adds a value &lt;code&gt;x&lt;/code&gt; of type &lt;code&gt;X&lt;/code&gt;. If &lt;code&gt;m&lt;/code&gt; is a long telescope: &lt;code&gt;m := [tele T1 T2 ... Tn]&lt;/code&gt; this function will grow with each step finally approaching something like &lt;code&gt;fun a =&amp;gt; f a t1 t2 .. tn&lt;/code&gt;, where &lt;code&gt;t1 : T1&lt;/code&gt;, &lt;code&gt;t2 : T2&lt;/code&gt; … &lt;code&gt;tn : Tn&lt;/code&gt;.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Installing Coq for Spacemacs</title>
   <link href="http://hyde.getpoole.com/misc/coq/2017/11/26/coq-in-spacemacs/"/>
   <updated>2017-11-26T00:47:00+01:00</updated>
   <id>http://hyde.getpoole.com/misc/coq/2017/11/26/coq-in-spacemacs</id>
   <content type="html">&lt;p&gt;I had a very hard time getting Coq to work as expected on Spacemacs. I collected everything I found and made this little tutorial.&lt;/p&gt;

&lt;p&gt;First of all we need to install &lt;strong&gt;Coq&lt;/strong&gt;, though &lt;strong&gt;Opam&lt;/strong&gt;. Debian-based users can do this with &lt;code&gt;apt-get&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install opam
opam install coq
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In fedora:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo yum install opam.x86_64
opam install coq
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next step is getting &lt;strong&gt;Proof General&lt;/strong&gt;. &lt;a href=&quot;https://proofgeneral.github.io/&quot;&gt;Proof General&lt;/a&gt; is a generic front-end for &lt;em&gt;proof assistants&lt;/em&gt; based on Emacs.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone https://github.com/ProofGeneral/PG ~/.emacs.d/lisp/PG
cd ~/.emacs.d/lisp/PG
make
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And add this to you dotfile in &lt;code&gt;dotspacemacs/user-init&lt;/code&gt;. This is done with &lt;code&gt;SPC f e d&lt;/code&gt; in &lt;strong&gt;Evil mode&lt;/strong&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(load &quot;~/.emacs.d/lisp/PG/generic/proof-site&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next step is installing &lt;strong&gt;company-coq&lt;/strong&gt; with &lt;strong&gt;MELPA&lt;/strong&gt;. Luckily, MELPA comes with the default Spacemacs installation. Just use &lt;code&gt;M-x package-refresh-contents RET&lt;/code&gt; followed by &lt;code&gt;M-x package-install RET company-coq RET&lt;/code&gt; to install and byte-compile company-coq and its dependencies (some of them will produce a few warnings; that’s OK).&lt;/p&gt;

&lt;p&gt;Next, we have to download a &lt;a href=&quot;https://github.com/olivierverdier/spacemacs-coq&quot;&gt;Coq layer&lt;/a&gt; for Spacemacs. This will provide all the keybindings and configurations we need to start working.&lt;/p&gt;

&lt;p&gt;Before dowloading the layer we need to change the &lt;code&gt;dotspacemacs-configuration-layer-path&lt;/code&gt; in our &lt;code&gt;.spacemacs&lt;/code&gt; dotfile. Find that line and change it to this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dotspacemacs-configuration-layer-path '(&quot;~/.spacemacs.d/&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This informs Spacemacs that we will keep our configuration layers in this folder, so then Spacemacs knows how to reach them. Now we need to create the directory and clone the layer.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir ~/.spacemacs.d
mkdir ~/.spacemacs.d/layers
cd ~/.spacemacs.d/layers
git clone https://github.com/olivierverdier/spacemacs-coq.git
mv spacemacs-coq coq
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now add &lt;code&gt;coq&lt;/code&gt; to your &lt;code&gt;dotspacemacs-configuration-layers&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We’re almost finished. Let’s go to the location of the layer we’ve just downloaded and open &lt;code&gt;config.el&lt;/code&gt;. We need to change the &lt;code&gt;proof-general-path&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(defvar proof-general-path &quot;~/.emacs.d/lisp/PG/generic/proof-site&quot;
  &quot;The path to proof general&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, the last step (totally optional) will serve &lt;strong&gt;Evil&lt;/strong&gt; users. If this is not configured, everytime you hit &lt;code&gt;&amp;lt;ESC&amp;gt;&lt;/code&gt;, Emacs will autocomplete the current line.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(setq evil-want-abbrev-expand-on-insert-exit nil)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This should be added before Evil loads, that means, before &lt;code&gt;dotspacemacs/user-init&lt;/code&gt; in your &lt;code&gt;.spacemacs&lt;/code&gt; file. This was found &lt;a href=&quot;https://github.com/syl20bnr/spacemacs/issues/8853&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Hopefully, you’ve installed Coq in Spacemacs. In case you’re curious there’s a tutorial included with &lt;strong&gt;Company Coq&lt;/strong&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;M-x company-coq-tutorial 
&lt;/code&gt;&lt;/pre&gt;

</content>
 </entry>
 

</feed>
